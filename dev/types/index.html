<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model types · SeisModels.jl documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SeisModels.jl documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../inbuilt_models/">Inbuilt models</a></li><li class="current"><a class="toctext" href>Model types</a><ul class="internal"><li><a class="toctext" href="#Type-hierarchy-1">Type hierarchy</a></li><li><a class="toctext" href="#Conversion-1">Conversion</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../io/">Model input-output</a></li><li><a class="toctext" href="../function_index/">Function index</a></li><li><a class="toctext" href="../references/">References</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Model types</a></li></ul><a class="edit-page" href="https://github.com/anowacki/SeisModels.jl/blob/master/docs/src/types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Model types</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Model-types-1" href="#Model-types-1">Model types</a></h1><h2><a class="nav-anchor" id="Type-hierarchy-1" href="#Type-hierarchy-1">Type hierarchy</a></h2><p>The module defines the SeisModel type and subtypes of this specify the kind of model (i.e., symmetry, nature of basis function, etc.).</p><p>The current type hierarchy is as follows:</p><ul><li><code>SeisModel</code>: Abstract type of all seismic models<ul><li><code>SeisModel1D</code>: Abstract type of all one-dimensonal (radially-symmetric) seismic models<ul><li><code>SteppedLayeredModel</code>: Type defined by layers with contstant properties.</li><li><code>LinearLayeredModel</code>: Type defined by layers with constant gradient.</li><li><code>PREMPolyModel</code>: Type defined by polynomials.</li></ul></li></ul></li></ul><p>As you can see, there are currently three types of models implemented, all 1D models, with polynomial, linear or constant basis within each layer.</p><h3><a class="nav-anchor" id="SteppedLayeredModel-1" href="#SteppedLayeredModel-1"><code>SteppedLayeredModel</code></a></h3><p>A <code>SteppedLayeredModel</code> is composed of a series of layers with constant properties in each layer.  The radii define the top of each layer.</p><p>An example of this is Weber et al.’s (2011) moon model:</p><p><img src="../SteppedLayeredModel_example.svg" alt="Example of a SteppedLayeredModel"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisModels.SteppedLayeredModel" href="#SeisModels.SteppedLayeredModel"><code>SeisModels.SteppedLayeredModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SteppedLayeredModel &lt;: SeisModel1D</code></pre><p>A <code>SteppedLayeredModel</code> contains <code>n</code> layers each with constant properties.</p></div></div><a class="source-link" target="_blank" href="https://github.com/anowacki/SeisModels.jl/blob/e70421ca232afad9e94f107c5fb45122fc1fa588/src/steppedlayeredmodel.jl#L1-L5">source</a></section><p>See the <a href="../function_index/#SeisModels.SteppedLayeredModel-Tuple{}">constructor</a> for details on creating <code>SteppedLayeredModel</code>s.</p><h3><a class="nav-anchor" id="LinearLayeredModel-1" href="#LinearLayeredModel-1"><code>LinearLayeredModel</code></a></h3><p>A <code>LinearLayeredModel</code> is described by radial nodes, between which the properties vary linearly.  Discontinutities are added by setting two subsequent nodes to have the same radii but different properties.</p><p>For example, a two-layer model for a planetesimal with radius 1 km and a liquid core at 0.3 km, with linearly varying properties, could be given by:</p><pre><code class="language-julia-repl">julia&gt; using SeisModels

julia&gt; m = LinearLayeredModel(r=[0, 0.3, 0.3, 1], vp=[1, 1, 1.8, 1], vs=[0, 0, 1, 0.7])
LinearLayeredModel(1.0, 4, [0.0, 0.3, 0.3, 1.0], [1.0, 1.0, 1.8, 1.0], [0.0, 0.0, 1.0, 0.7], Float64[], false, Float64[], Float64[], Float64[], Float64[], Float64[], false, Float64[], Float64[])</code></pre><p>You can see that the nodes are used to define a constant lower layer and linearly-varying upper layer:</p><p><img src="../LinearLayeredModel_example.svg" alt="Example of a LinearLayeredModel"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisModels.LinearLayeredModel" href="#SeisModels.LinearLayeredModel"><code>SeisModels.LinearLayeredModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LinearLayeredModel &lt;: SeisModel1D</code></pre><p>A <code>LinearLayeredModel</code> contains <code>n</code> points at which velocities are defined, with linear interpolation between them.  Hence there are <code>n - 1</code> layers.</p><p>Discontinuities are represented by two layers with the same radii.</p></div></div><a class="source-link" target="_blank" href="https://github.com/anowacki/SeisModels.jl/blob/e70421ca232afad9e94f107c5fb45122fc1fa588/src/linearlayeredmodel.jl#L1-L8">source</a></section><p>See the <a href="../function_index/#SeisModels.LinearLayeredModel-Tuple{}">constructor</a> for details on creating <code>LinearLayeredModel</code>s.</p><h3><a class="nav-anchor" id="PREMPolyModel-1" href="#PREMPolyModel-1"><code>PREMPolyModel</code></a></h3><p><code>PREMPolyModel</code>s are parameterised (like PREM) by polynomials in each layer, considering the normalised radius <span>$x=r/a$</span>, where <span>$a$</span> is the surface radius. Clearly, <code>SteppedLayeredModel</code>s and <code>LinearLayeredModel</code>s are specific cases of a polynomial parameterisation.</p><p>For example, PREM’s outer core density in g/cm³ is given by <span>$12.5815 - 1.2638x - 3.6426x^2 - 5.5281x^3\,.$</span></p><p>One could imagine a single-layer planet whose velocities are described by</p><div>\[V_\mathrm{P}(x) = 3 - 2x^2 - x^3\,,\]</div><p>where <span>$V_\mathrm{S} = V_\mathrm{P}/\alpha$</span>, and <span>$\alpha = 1.7$</span>.</p><pre><code class="language-julia-repl">julia&gt; radii = [500]    # Layer tops in km
1-element Array{Int64,1}:
 500

julia&gt; vps =   reshape( # Ensure we have a matrix with 1 column and 4 rows
               [3       # x^0 coefficients in km/s
                0       # x^1
               -2       # x^2
               -1],     # x^3
                :, 1)
4×1 Array{Int64,2}:
  3
  0
 -2
 -1

julia&gt; α = 1.7
1.7

julia&gt; vss = vps./α
4×1 Array{Float64,2}:
  1.7647058823529411
  0.0
 -1.1764705882352942
 -0.5882352941176471

julia&gt; m = PREMPolyModel(r=radii, vp=vps, vs=vss)
PREMPolyModel(500.0, 1, [500.0], [3.0; 0.0; -2.0; -1.0], [1.7647058823529411; 0.0; -1.1764705882352942; -0.5882352941176471], Array{Float64}(undef,0,0), false, Array{Float64}(undef,0,0), Array{Float64}(undef,0,0), Array{Float64}(undef,0,0), Array{Float64}(undef,0,0), Array{Float64}(undef,0,0), false, Array{Float64}(undef,0,0), Array{Float64}(undef,0,0), NaN)</code></pre><p>Note that the polynomial coefficients appear as the row of a matrix, and each layer occupies a column.</p><pre><code class="language-julia-repl">julia&gt; using Plots: plot, plot!, vline!, savefig

julia&gt; p = plot(xlabel=&quot;Radius (km)&quot;, ylabel=&quot;Velocity (km/s) or Density (g/cm^3)&quot;, title=&quot;PREMPolyModel example&quot;, framestyle=:box, grid=false)
Plot{Plots.GRBackend() n=0}

julia&gt; for (f, name) in zip((vp, vs), (&quot;Vp&quot;, &quot;Vs&quot;))
           plot!(p, r-&gt;f(m, r), 0, surface_radius(m), label=name)
       end

julia&gt; vline!(p, m.r, line=(0.5,:dash), label=&quot;Layer tops&quot;)
Plot{Plots.GRBackend() n=3}

julia&gt; savefig(&quot;PREMPolyModel_example.svg&quot;)</code></pre><p><img src="../PREMPolyModel_example.svg" alt="Example of a PREMPolyModel"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisModels.PREMPolyModel" href="#SeisModels.PREMPolyModel"><code>SeisModels.PREMPolyModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PREMPolyModel &lt;: SeisModel1D</code></pre><p>Type describing the Earth as a set of layers within which properties vary according to a set of polynomials.</p><p>Physical parameters are represented by arrays of size <code>(order+1, n)</code>, where <code>n</code> is the number of layers, and <code>order</code> is the order of polynomial which is used to represent the parameter.  Hence a constant layer has size <code>(1,n)</code>, and to compute the value of <code>x</code> in layer <code>i</code>, for an Earth radius of <code>a</code> km, at a radius of <code>r</code> km, the expression is:</p><pre><code class="language-none">val_x = x[i,1] + (r/a)*x[i,2] + (r/a)^2*x[i,3] ... (r/a)^order*x[i,order+1]</code></pre><p>The reference frequency in Hz for the velocities in case of attenuation is given by the <code>fref</code> field.  If <code>fref</code> is <code>NaN</code>, then no reference frequency is defined for the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/anowacki/SeisModels.jl/blob/e70421ca232afad9e94f107c5fb45122fc1fa588/src/prempolymodel.jl#L3-L20">source</a></section><p>See the <a href="../function_index/#SeisModels.PREMPolyModel-Tuple{}">constructor</a> for details on creating <code>PREMPolyModel</code>s.</p><h4><a class="nav-anchor" id="Attenuation-1" href="#Attenuation-1">Attenuation</a></h4><p>Attenuation in <code>PREMPolyModels</code> is specified as in PREM (see equation (3) in section 6 on page 309).  That means, the shear and bulk quality factors (<span>$Q_\mu$</span> and <span>$Q_\kappa$</span> respectively) control the effective velocities, which will vary by wave frequency.</p><p>By default, velocities for <code>PREMPolyModel</code>s are returned at the reference frequency, which can be found with <a href="../function_index/#SeisModels.reffrequency"><code>reffrequency</code></a> and is given in Hz.  To obtain velocities at other frequencies, just pass a target frequency to the relevant function via the <code>freq</code> keyword argument.</p><p>In this example, we ask for the Voigt average isotropic shear-wave velocity at radius 4500 km for a frequency of 0.01 Hz (equally, 100 s period):</p><pre><code class="language-julia-repl">julia&gt; vs(PREM, 4500, freq=0.01)
6.840542771852348</code></pre><h2><a class="nav-anchor" id="Conversion-1" href="#Conversion-1">Conversion</a></h2><p>Conversion can be performed between any of the above model types.  Note that in some cases (e.g., <code>SteppedLayeredModel</code> to <code>LinearLayeredModel</code> or <code>LinearLayeredModel</code> to <code>PREMPolyModel</code>) no information is lost, whilst in others (e.g., <code>PREMPolyModel</code> to <code>LinearLayeredModel</code> or to <code>SteppedLayeredModel</code>) the converted model can only be an approximation to the original.</p><p>To convert between model types, simply pass one model to the constructor of another.  For example:</p><pre><code class="language-julia-repl">julia&gt; m = PREM;

julia&gt; m2 = LinearLayeredModel(PREM);

julia&gt; typeof(m2)
LinearLayeredModel

julia&gt; ≈(mass(m), mass(m2))
false</code></pre><p>See the <a href="../function_index/#conversion-1">conversion section</a> for details.</p><footer><hr/><a class="previous" href="../inbuilt_models/"><span class="direction">Previous</span><span class="title">Inbuilt models</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
